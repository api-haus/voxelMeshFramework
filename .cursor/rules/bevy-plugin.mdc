---
globs: crates/**/src/**/*.rs
alwaysApply: false
---

### Bevy Plugin Structure Rule

Structure Bevy code around feature-scoped plugins. Register systems, resources, and events inside plugins; keep `lib.rs` focused on adding plugins only.

#### Principles
- One plugin per feature module: `PlayerPlugin`, `CameraPlugin`, `AtmospherePlugin`, `WorldPlugin`, `UiPlugin`, `DebugPlugin`.
- Plugins own their module (`src/<feature>/`) and re-export a small prelude if helpful.
- Register systems in `Plugin::build`; avoid adding systems directly in `lib.rs`.
- Group and order systems with `SystemSet`s and `.configure_sets`.
- Register resources/events in the plugin (`init_resource`, `insert_resource`, `add_event`).
- Prefer `run_if`, `in_state`, and event-driven systems.
- Keep domain logic pure; plugins only do wiring (aligns with DOP).

#### Suggested module layout (example: player)
src/player/
  mod.rs           // defines `PlayerPlugin`, re-exports public types
  spawn.rs         // spawn systems
  movement.rs      // movement systems
  actions.rs       // input/actions systems
  config.rs        // PlayerConfig resource

#### Plugin skeleton (example)
```rust
use bevy::prelude::*;

pub struct PlayerPlugin;

#[derive(SystemSet, Debug, Clone, Copy, Eq, PartialEq, Hash)]
pub enum PlayerSet {
	Input,
	Movement,
	Post,
}

impl Plugin for PlayerPlugin {
	fn build(&self, app: &mut App) {
		app
			.init_resource::<player::config::PlayerConfig>()
			.add_event::<player::actions::PlayerPunchEvent>()
			.configure_sets(
				Update,
				(PlayerSet::Input, PlayerSet::Movement, PlayerSet::Post).chain(),
			)
			.add_systems(Startup, player::spawn::spawn_player)
			.add_systems(
				Update,
				(
					player::actions::read_actions.in_set(PlayerSet::Input),
					player::movement::apply_movement.in_set(PlayerSet::Movement),
					player::movement::visualize_player_movement.in_set(PlayerSet::Post),
				),
			);
	}
}
```

#### `lib.rs` usage
```rust
app.add_plugins((
	PlayerPlugin,
	CameraPlugin,
	AtmospherePlugin,
	// other feature plugins...
));
```

#### Ordering and cross-plugin dependencies
- Use `.configure_sets(Update, (...).chain())` for ordered phases.
- Use `.after(...)` / `.before(...)` for cross-plugin coordination.
- Gate with `.run_if(...)` or `in_state(...)` for contextual activation.

#### Testing
- Keep logic in pure modules and unit-test them.
- Add integration tests to verify plugin registration and set ordering.
